public class Sum {

    public static int sum(int[] arr) {
        return sum(arr, 0);
    }

    // 此方法的宏观语义 (重点关注):
    // 计算 arr[l...n) 这个区间内所有数字的和

    // a. 将原始问题抽象成递归问题 (思考如何构造递归方法时一般会用到此过程)
    // 1. arr[0] + arr[1] + arr[2] + arr[3] + ... + arr[n-2] + arr[n-1]
    // 2. arr[0] + (arr[1] + arr[2] + arr[3] + ... + arr[n-2] + arr[n-1])
    // 3. arr[0] + arr[1] + (arr[2] + arr[3] + ... + arr[n-2] + arr[n-1])
    // ...
    // 4. arr[0] + arr[1] + arr[2] + arr[3] + ... + (arr[n-2] + arr[n-1])
    // 5. arr[0] + arr[1] + arr[2] + arr[3] + ... + arr[n-2] + (arr[n-1])

    // b. 将原始问题抽象成递归方法 (思考和编写递归代码时一般会用到此过程)
    // 从上到下为程序的实际调用顺序, 递归方法依次入栈: [1] -> [1, 2] -> [1, 2, 3] -> [1, 2, 3, 4] -> [1, 2, 3, 4, 5] top
    // 1. sum(arr, 0)
    // 2. arr[0] + sum(arr, 1) [更小的同一个问题]
    // 3. arr[0] + arr[1] + sum(arr, 2) [更小的同一个问题]
    // ...
    // 4. arr[0] + arr[1] + arr[2] + arr[3] + ... + arr[n-2] + sum(arr, n-1) [更小的同一个问题]
    // 5. arr[0] + arr[1] + arr[2] + arr[3] + ... + arr[n-2] + arr[n-1] + sum(arr, n) [更小的同一个问题]

    // c. 从上到下为程序的实际运算顺序, 递归方法依次出栈: [1, 2, 3, 4, 5] -> [1, 2, 3, 4] -> [1, 2, 3] -> [1, 2] -> [1] top
    // 5. arr[0] + arr[1] + arr[2] + arr[3] + ... + arr[n-2] + arr[n-1] + (0)
    // 4. arr[0] + arr[1] + arr[2] + arr[3] + ... + arr[n-2] + (arr[n-1] + 0)
    // ...
    // 3. arr[0] + arr[1] + (arr[2] + arr[3] + ... + arr[n-2] + arr[n-1] + 0)
    // 2. arr[0] + (arr[1] + arr[2] + arr[3] + ... + arr[n-2] + arr[n-1] + 0)
    // 1. (arr[0] + arr[1] + arr[2] + arr[3] + ... + arr[n-2] + arr[n-1] + 0)

    // 在编写递归方法代码时, 需要关注两点:
    // a. 关注此方法的宏观语义, 关注当前方法能够完成的任务 (而不需要太过于纠结方法内调用的递归方法, 只需知道调用的递归方法能完成它的任务即可)
    // 此例中 sum(arr, 0) 的宏观语义就是求第 0 个数后面的所有和, 求和方式就是: 第 0 个数加上第 1 个数后面的所有和, (而不需要太过于纠结第 1 个数后面的所有和是如何具体调用的)
    // b. 关注最基本的问题, 即结束递归的条件 (此时需要关注递归调用的顺序)
    // 此例中, 随着递归的依次调用, arr 数组内需要计算的元素在逐渐减少, 当 arr 数组内没有任何元素的时候, 也就是 l == arr.length 的时候, 此时可以结束递归调用逻辑, 后续程序会依次往上执行具体的加法运算
    private static int sum(int[] arr, int l) {
        // 递归终止 (最小的问题)
        if (l == arr.length) {
            return 0;
        }
        // 递归调用 (更小的同等问题)
        return arr[l] + sum(arr, l + 1);
    }

}
